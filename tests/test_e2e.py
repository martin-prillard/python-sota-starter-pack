"""End-to-end tests for each project type generated by the cookiecutter template."""

import shutil
import subprocess
import tempfile
from pathlib import Path

import pytest


@pytest.fixture
def template_dir():
    """Get the template directory."""
    return Path(__file__).parent.parent.absolute()


@pytest.fixture
def temp_dir():
    """Create a temporary directory for generated projects."""
    temp_path = tempfile.mkdtemp(prefix="cookiecutter-test-")
    yield Path(temp_path)
    # Cleanup
    if Path(temp_path).exists():
        shutil.rmtree(temp_path, ignore_errors=True)


def run_command(cmd: list[str], cwd: Path, check: bool = True) -> subprocess.CompletedProcess:
    """Run a command and return the result."""
    result = subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=True,
        text=True,
        check=check,
    )
    return result


def generate_project(
    template_dir: Path,
    output_dir: Path,
    project_type: str,
    project_slug: str = "test-project",
) -> Path:
    """Generate a project using cookiecutter."""
    from cookiecutter.main import cookiecutter

    context = {
        "project_name": "Test Project",
        "project_slug": project_slug,
        "project_description": f"A test {project_type} project",
        "author_name": "Test Author",
        "author_email": "test@example.com",
        "project_type": project_type,
        "python_version": "3.12",
        "use_docker": "yes",
        "publish_to_pypi": "no",
        "pypi_username": "",
        "pypi_token": "",
        "use_ci": "yes",
        "git_provider": "gitlab",
        "gitlab_url": "https://gitlab.com",
        "gitlab_group": "test-group",
        "github_org": "",
        "sonarqube_token": "",
    }

    cookiecutter(
        str(template_dir),
        no_input=True,
        extra_context=context,
        output_dir=str(output_dir),
    )

    project_path = output_dir / project_slug
    assert project_path.exists(), f"Project directory {project_path} was not created"
    return project_path


class TestLibraryProject:
    """End-to-end tests for library project type."""

    def test_library_generation_and_setup(self, template_dir, temp_dir):
        """Test generating a library project and running setup commands."""
        project_slug = "test-library"
        project_path = generate_project(template_dir, temp_dir, "library", project_slug)

        # Test 1: Install dependencies
        result = run_command(
            ["uv", "sync", "--extra", "dev"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to install dependencies: {result.stderr}"

        # Test 2: Install pre-commit hooks
        result = run_command(
            ["uv", "run", "pre-commit", "install"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to install pre-commit hooks: {result.stderr}"

        # Test 3: Run tests
        result = run_command(
            ["uv", "run", "pytest"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Tests failed: {result.stderr}"

        # Test 4: Run linting
        result = run_command(
            ["uv", "run", "ruff", "check", "."],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Linting failed: {result.stderr}"

        # Test 5: Format check
        result = run_command(
            ["uv", "run", "ruff", "format", "--check", "."],
            cwd=project_path,
        )
        # Format check might fail if code needs formatting, that's okay
        # We just want to make sure the command runs

        # Test 6: Type checking
        result = run_command(
            ["uv", "run", "ty", "check"],
            cwd=project_path,
        )
        # Type checking might have warnings, but should not crash
        assert result.returncode in [0, 1], f"Type checking crashed: {result.stderr}"

        # Test 7: Build package (install build first if needed)
        # Try uv build first, fallback to python -m build
        result = run_command(
            ["uv", "build"],
            cwd=project_path,
            check=False,
        )
        if result.returncode != 0:
            # Fallback to python -m build, but install build first
            run_command(
                ["uv", "pip", "install", "build"],
                cwd=project_path,
            )
            result = run_command(
                ["python", "-m", "build"],
                cwd=project_path,
            )
        assert result.returncode == 0, f"Build failed: {result.stderr}"
        assert (project_path / "dist").exists(), "dist directory was not created"


class TestFastAPIProject:
    """End-to-end tests for FastAPI project type."""

    def test_fastapi_generation_and_setup(self, template_dir, temp_dir):
        """Test generating a FastAPI project and running setup commands."""
        project_slug = "test-fastapi"
        project_path = generate_project(template_dir, temp_dir, "fastapi", project_slug)

        # Test 1: Install dependencies
        result = run_command(
            ["uv", "sync", "--extra", "dev"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to install dependencies: {result.stderr}"

        # Test 2: Install pre-commit hooks
        result = run_command(
            ["uv", "run", "pre-commit", "install"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to install pre-commit hooks: {result.stderr}"

        # Test 3: Run tests
        result = run_command(
            ["uv", "run", "pytest"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Tests failed: {result.stderr}"

        # Test 4: Verify FastAPI app can be imported
        result = run_command(
            ["uv", "run", "python", "-c", f"from {project_slug}.main import app; print('OK')"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to import FastAPI app: {result.stderr}"

        # Test 5: Check that uvicorn command works (dry run)
        # We'll just verify the command exists and can be called
        result = run_command(
            ["uv", "run", "uvicorn", "--help"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"uvicorn not available: {result.stderr}"

        # Test 6: Verify main module can be run
        main_file = project_path / "src" / project_slug / "main.py"
        assert main_file.exists(), "main.py should exist"


class TestStreamlitProject:
    """End-to-end tests for Streamlit project type."""

    def test_streamlit_generation_and_setup(self, template_dir, temp_dir):
        """Test generating a Streamlit project and running setup commands."""
        project_slug = "test-streamlit"
        project_path = generate_project(template_dir, temp_dir, "streamlit", project_slug)

        # Test 1: Install dependencies
        result = run_command(
            ["uv", "sync", "--extra", "dev"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to install dependencies: {result.stderr}"

        # Test 2: Install pre-commit hooks
        result = run_command(
            ["uv", "run", "pre-commit", "install"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to install pre-commit hooks: {result.stderr}"

        # Test 3: Run tests
        result = run_command(
            ["uv", "run", "pytest"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Tests failed: {result.stderr}"

        # Test 4: Verify Streamlit can be imported
        result = run_command(
            ["uv", "run", "python", "-c", "import streamlit; print('OK')"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to import streamlit: {result.stderr}"

        # Test 5: Check that streamlit command works
        result = run_command(
            ["uv", "run", "streamlit", "--help"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"streamlit not available: {result.stderr}"

        # Test 6: Verify main.py exists and can be imported
        main_file = project_path / "src" / project_slug / "main.py"
        assert main_file.exists(), "main.py should exist"


class TestDataScienceProject:
    """End-to-end tests for Data Science project type."""

    def test_datascience_generation_and_setup(self, template_dir, temp_dir):
        """Test generating a Data Science project and running setup commands."""
        project_slug = "test-datascience"
        project_path = generate_project(template_dir, temp_dir, "datascience", project_slug)

        # Test 1: Install dependencies
        result = run_command(
            ["uv", "sync", "--extra", "dev"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to install dependencies: {result.stderr}"

        # Test 2: Install pre-commit hooks
        result = run_command(
            ["uv", "run", "pre-commit", "install"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to install pre-commit hooks: {result.stderr}"

        # Test 3: Run tests
        result = run_command(
            ["uv", "run", "pytest"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Tests failed: {result.stderr}"

        # Test 4: Verify Jupyter Lab can be imported
        result = run_command(
            ["uv", "run", "python", "-c", "import jupyterlab; print('OK')"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to import jupyterlab: {result.stderr}"

        # Test 5: Verify data science libraries are available
        result = run_command(
            [
                "uv",
                "run",
                "python",
                "-c",
                "import pandas, numpy, matplotlib, sklearn; print('OK')",
            ],
            cwd=project_path,
        )
        assert result.returncode == 0, f"Failed to import data science libraries: {result.stderr}"

        # Test 6: Check that jupyter command works
        result = run_command(
            ["uv", "run", "jupyter", "--help"],
            cwd=project_path,
        )
        assert result.returncode == 0, f"jupyter not available: {result.stderr}"

        # Test 7: Verify notebooks directory exists
        notebooks_dir = project_path / "notebooks"
        assert notebooks_dir.exists(), "notebooks directory should exist"


@pytest.mark.integration
class TestAllProjectTypes:
    """Integration tests that verify all project types work correctly."""

    def test_all_project_types_generate_successfully(self, template_dir, temp_dir):
        """Test that all project types can be generated."""
        project_types = ["library", "fastapi", "streamlit", "datascience"]

        for project_type in project_types:
            project_slug = f"test-{project_type}"
            project_path = generate_project(template_dir, temp_dir, project_type, project_slug)

            # Verify basic structure
            assert (project_path / "pyproject.toml").exists(), f"{project_type}: pyproject.toml missing"
            assert (project_path / "README.md").exists(), f"{project_type}: README.md missing"
            assert (project_path / "src" / project_slug).exists(), f"{project_type}: src directory missing"

            # Verify dependencies can be installed
            result = run_command(
                ["uv", "sync", "--extra", "dev"],
                cwd=project_path,
            )
            assert result.returncode == 0, f"{project_type}: Failed to install dependencies"

            # Verify tests can run
            result = run_command(
                ["uv", "run", "pytest"],
                cwd=project_path,
            )
            assert result.returncode == 0, f"{project_type}: Tests failed"
